---
title: "Weissman-replication-raw-processed"
author: "Marton Kovacs"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: html_document
---

# Load packages

```{r load packages}
library(tidyverse)
library(janitor)
library(purrrlyr)
library(osfr)
library(lubridate)
```

# Load helper functions

```{r load helper functions}
source("utils.R")
```

# Download data from OSF
## OSF auth (until project is public)
osf_auth(token = read_lines("osf_token_write_martonbalazskovacs.txt"))
```{r osf authentication}
```

## Connect to data OSF folder
```{r osf connect to OSF folder}
data_guid <- "9knds"

weissman_project <- osf_retrieve_node(data_guid)
```

## Download data locally

```{r osf download data}
local_data_pth <- file.path("data","Raw")

create_local_structure(local_data_pth)

data_files <- 
  weissman_project %>% 
  osf_ls_files() %>% 
  filter(name == "Raw") %>% 
  osf_ls_files() 

data_files %>% 
  group_by(name) %>% # for each experiment type
  do(download_files(.,local_data_pth))

# uncomment following line to remove the data   
# remove_local_data(local_data_pth)
```

# Import data

```{r}
# Saving subfolder names
subfolder <- list("primeprobe", "flanker", "stroop", "simon")

# Reading in data
raw <-
  tibble(task = subfolder,
         response = map(subfolder,
                       ~ read_plus(subfolder_name = .x,
                                   pattern = ".tsv$",
                                   path = "data/Raw/",
                                   sep = "\t")))
```

# Check whether each participant completed the study

## Number of trials for each task

* Primeprobe
** practice = 24
** test = 388
** total = 412
* Flanker, Simon, Stroop
** practice = 24
** test = 324
** total = 348

```{r}
map(raw$response,
    . %>% 
      group_by(participant_id, id, task, isPractice) %>% 
      count() %>%
      mutate(complete = case_when(isPractice == 1L & n == 24 ~ "complete",
                                  task == "primeprobe" & isPractice == 0L & n == 388 ~ "complete",
                                  task %in% c("flanker", "simon", "stroop") & isPractice == 0L & n == 324 ~ "complete",
                                  TRUE ~ "incomplete")) %>% 
      group_by(isPractice, complete) %>% 
      count())
```

# Save practice trials to a separate df and then drop them

```{r}
raw <-
  raw %>%
  mutate(practice = map(response,
                        ~ filter(., isPractice == 1L)),
         response = map(response,
                        ~ filter(., isPractice == 0L)))
```

# Calculate accuracy in each task for each participant

```{r}
raw <-
  raw %>%
  mutate(response = map(response,
                    ~ mutate(., isCorrect = case_when(responseTarget == responseContent ~ 1L,
                                                    responseTarget != responseContent ~ 0L))),
         response = map(response,
                     . %>% 
                      group_by(participant_id, id) %>% 
                      mutate(prop = sum(isCorrect) / n() * 100,
                             dropParticipantAcc = case_when(prop < 70 ~ 1L,
                                              TRUE ~ 0L))))
```

# Check participants who completed the tasks more than once and show the responses descriptive information

```{r}
participant_duplicate <-
  map(raw$response,
    . %>% 
      select(participant_id, id, task, trialId, consentTime, prop)) %>% 
      reduce(., bind_rows) %>% 
  group_by(participant_id, id, task, consentTime, prop) %>% 
  count() %>%
  group_by(participant_id) %>% 
  mutate(N = n(),
         consentTime = as_datetime(consentTime / 1000, tz = "Europe/Prague")) %>% 
  filter(N != 1)

participant_duplicate
```

# Exclude duplicate responses

* If the participant scored 0% on the first try we keep the second response
* If the participant scored more than 0% on the first try we keep the first response
* We exclude the responses from tasks that were not sent to a given participant

```{r}
participant_duplicate_drop <-
  participant_duplicate %>%
  filter(id %in% c(82, 77, 57, 8, 84)) %>% 
  select(participant_id, id)

raw <- 
  raw %>%
  mutate(response = map(response,
                        ~ anti_join(., participant_duplicate_drop, by = c("participant_id", "id"))))
```

# Calucalte the response time variable

```{r}
raw$response[[1]] <-
  raw %>% 
  filter(task == "primeprobe") %>% 
  unnest(response) %>%
  mutate(rt = responseTime - probeOffset)

raw$response[[2]] <- 
  raw %>% 
  filter(task == "flanker") %>% 
  unnest(response) %>%
  mutate(rt = responseTime - stimOffset)

raw$response[[3]] <-
  raw %>%
  filter(task == "stroop") %>% 
  unnest(response) %>%
  mutate(rt = responseTime - stimOnset)

raw$response[[4]] <-
  raw %>%
  filter(task == "simon") %>% 
  unnest(response) %>%
  mutate(rt = responseTime - stimOffset)
```

# Calucalte the mean response time and SD for exclusion

```{r}
raw <-
  raw %>%
  mutate(rtOutliers = map(response,
                        . %>%
                          group_by(participant_id) %>% 
                          summarise(rtMean = mean(rt, na.rm = T),
                                    rtSd = sd(rt, na.rm = T)) %>% 
                          ungroup() %>%
                          mutate(rtMeanGrand = mean(rtMean),
                                 rtSdGrand = sd(rtMean),
                                 dropParticipantRt = case_when(rtMeanGrand + rtSdGrand < rtMean ~ 1L,
                                                     rtMeanGrand - rtSdGrand > rtMean ~ 1L,
                                                     TRUE ~ 0L))),
         response = map2(response, rtOutliers,
                         ~ left_join(.x, .y, by = "participant_id")))
```

# Add variable storing previous congruency

```{r}
raw <-
  raw %>%
  mutate(response = map(response,
                        . %>% 
                          group_by(participant_id) %>% 
                          mutate(isPrevCong = case_when(trialId == 24 ~ NA_integer_,
                                                        trialId > 24 & lag(isCongruent) == 1L ~ 1L,
                                                        trialId > 24 & lag(isCongruent) == 0L ~ 0L),
                                 isPrevCorrect = case_when(trialId == 24 ~ NA_integer_,
                                                           trialId > 24 & lag(isCorrect) == 1L ~ 1L,
                                                           trialId > 24 & lag(isCorrect) == 0L ~ 0L))))
```

# Participant level exclusion

* 1: mean accuracy on their respective task was below 70%
* 2: mean reaction time was more than 2.5 SDs away from the mean of their group

```{r}
raw <-
  raw %>%
  mutate(response = map(response,
                    ~ filter(.,
                             dropParticipantAcc == 1L,
                             dropParticipantRt == 1L)))
```

# Trial level exclusion for rt analysis

* 1: First trial for each participant
* 2: Error trials
* 3: Trials following error trials
* 4: Outliers, trials 2.5 SDs away from the conditional mean of the participant
* 5: Trials following outlier trials

```{r}
#raw <-
  #raw %>% 
 # mutate(response = )
```

# Trial level exclusion for error analysis
* 1: Outliers, trials 2.5 SDs away from the conditional mean of the participant
* 2: Trials following outlier trials
* 3: First trial for each participant

```{r}

```

# Save task to individual dataframes
## TODO: Rewrite this with a function
```{r}
primeprobe_raw <- raw %>% filter(task == "primeprobe") %>% select(response) %>% unnest()

flanker_raw <- raw %>% filter(task == "flanker") %>% select(response) %>% unnest()

stroop_raw <- raw %>% filter(task == "stroop") %>% select(response) %>% unnest()

simon_raw <- raw %>% filter(task == "simon") %>% select(response) %>% unnest()
```